"""GridLAB-D Geodata Utility Package

The utility package obtains information about utilities and their service
territories.  The information is collected from Homeland Infrastructure
Foundation-Level Data (HIFLD) website.  See
https://hifld-geoplatform.opendata.arcgis.com/datasets/electric-retail-service-territories.
to details.

The 'location' directive accepts a list of positions and obtains utility data at
those positions.

The 'path' function accepts a list of CSV files containing latitude and
longtitude coordinates and obtain utility information at those positions.

Note, the utility package does not support the resolution option.

The current fields generated by the utility dataset include the following:

    OBJECTID
    ID
    NAME
    ADDRESS
    CITY
    STATE
    ZIP
    TELEPHONE
    TYPE
    COUNTRY
    NAICS_CODE
    NAICS_DESC
    SOURCE
    SOURCEDATE
    VAL_METHOD
    VAL_DATE
    WEBSITE
    REGULATED
    CNTRL_AREA
    PLAN_AREA
    HOLDING_CO
    SUMMR_PEAK
    WINTR_PEAK
    SUMMER_CAP
    WINTER_CAP
    NET_GEN
    PURCHASED
    NET_EX
    RETAIL_MWH
    WSALE_MWH
    TOTAL_MWH
    TRANS_MWH
    CUSTOMERS
    YEAR
    SHAPE_Length
    SHAPE_Area
"""

version = 1

import os, sys
import math
import pandas
import geopandas
import fiona
import pickle
import numpy as np
from shapely.geometry import Point

#
# Defaults
#
default_options = {
}

default_config = {
    "repourl" : "http://geodata.gridlabd.us/utility",
    "resolution" : 10.0,
    "cachedir" : "/usr/local/share/gridlabd/geodata/utility",
}

kmlfile = None
kmldata = None
csvfile = None
csvdata = None

TODO = 199 # utility id to use until get_utility works ok

def read_kml():
    global kmldata
    if type(kmldata) == type(None):
        if not os.path.exists(kmlfile):
            verbose("Downloading kml")
            geopandas.io.file.fiona.drvsupport.supported_drivers['KML'] = 'rw'
            kmldata = geopandas.read_file(geodata.get_config("repourl")+"/geometry.kml", driver="KML")
            verbose("Caching kml")
            with open(kmlfile, "wb") as fh:
                pickle.dump(kmldata,fh)
        else:
            verbose("Reading kml")
            with open(kmlfile, "rb") as fh:
                kmldata = pickle.load(fh)
    return kmldata

def read_csv():
    global csvdata
    if type(csvdata) == type(None):
        if not os.path.exists(csvfile):
            verbose("Downloading csv")
            csvdata = pandas.read_csv(geodata.get_config("repourl")+"/information.csv",
                na_values=["-999999","NOT AVAILABLE"])
            verbose("Caching csv")
            csvdata.to_csv(csvfile)
        else:
            verbose("Reading csv")
            csvdata = pandas.read_csv(csvfile)
    return csvdata

def get_information(id,field=None):
    data = read_csv()
    if field:
        return data[field][id]
    else:
        return data.iloc[id]

def get_geometry(id):
    data = read_csv()
    geom = read_kml()
    return geom["geometry"][id]

def get_utility(pos):
    kml = read_kml()
    result = list(kml[kml.contains(Point(pos[1],pos[0]))==True].index)
    return result

def get_distance(pos1, pos2):
    """Compute haversine distance between two locations

    ARGUMENTS

        pos1, pos2 (float tuple)   Specifies the two geographic endpoints as a
                                   (latitude,longtitude) tuple
    RETURNS

        float   The distance between the two points in meters.
    """
    lat1 = pos1[0]*math.pi/180
    lat2 = pos2[0]*math.pi/180
    lon1 = pos1[1]*math.pi/180
    lon2 = pos2[1]*math.pi/180
    a = math.sin((lat2-lat1)/2)**2+math.cos(lat1)*math.cos(lat2)*math.sin((lon2-lon1)/2)**2
    return 6371e3*(2*np.arctan2(np.sqrt(a),np.sqrt(1-a)))

def get_position(pos):
    """Compute the (latitude,longitude) tuple of the position given

    ARGUMENTS
        pos (str)   The position given as a comma-delimeted string
        pos (tuple) The position given as a (lat,lon) tuple

    RETURNS
        tuple   The position given as a (lat,lon) tuple
    """
    if type(pos) is str:
        return list(map(lambda x: float(x),pos.split(",")))
    return pos

def apply(data, options=default_options, config=default_config):
    """Obtain the utility information for the locations specified"""
    if not args:
        error(f"{DATASET}.get_location({args}) missing one or more position arguments",geodata.E_SYNTAX)
    info = {"latitude":[],"longitude":[],DATASET:[]}
    resolution = geodata.get_resolution()
    pos0 = None
    keys = read_csv().keys()
    for key in keys:
        info[key] = []
    for arg in args:
        pos = get_position(arg)
        id = get_utility(pos)
        if len(id) == 0:
            data = {}
        else:
            if len(id) > 1:
                warning(f"position {pos} yielded more than one result, using first only")
            data = get_information(id[0])
        if pos0:
            d = get_distance(pos0,pos)
        else:
            d = 0
        info["latitude"].append(pos[0])
        info["longitude"].append(pos[1])
        for key in keys:
            if key in data.keys():
                info[key].append(data[key])
            else:
                info[key].append("")
        if "NAME" in data.keys():
            info[DATASET].append(data["NAME"])
        else:
            info[DATASET].append("")
        pos0 = pos
    result = pandas.DataFrame(info)
    result["id"] = geodata.distance(list(zip(info["latitude"],info["longitude"])))
    result.set_index("id")
    return result

# perform validation tests
if __name__ == '__main__':

    import unittest
    import numpy
    IDPRECISION = 3
    kmlfile = "/usr/local/share/gridlabd/geodata/utility/geometry.kml"
    csvfile = "/usr/local/share/gridlabd/geodata/utility/information.csv"
    os.makedirs("/usr/local/share/gridlabd/geodata/utility",exist_ok=True)

    class TestDataset(unittest.TestCase):

        def test_utility_geometry(self):
            self.assertEqual(numpy.round(get_geometry(199).area,2),17.74)
        
        def test_utility_name(self):
            self.assertEqual(get_information(199,"NAME"),"PACIFIC GAS & ELECTRIC CO.")
        
        def test_utility_information(self):
            self.assertEqual(get_information(199)["NAME"],"PACIFIC GAS & ELECTRIC CO.")

    unittest.main()
