"""Convert EnergyPlus building to GLM load"""

import sys, os 
import json
import getopt
import datetime
import re

from geometry import Polygon
from geohash import geohash
from idfparse import IDF

config = {
	"input" : "idf",
	"output" : "glm",
	# "from" : ["ami","scada","onpoint-weather", "table"],
	# "type" : ["ceus","rbsa","climate", "object"],
	}

def help():
	print('Syntax:')
	print(f'{config["input"]}2{config["output"]}.py -i|--input <input-file>[,<input-file>[,...]] -o|--output <output-file> [options ...]')
	print(f'  -c|--config	: [OPTIONAL] display converter configuration')
	print(f'  -i|--ifile	 : [REQUIRED] {config["input"]} input file name')
	print(f'  -o|--ofile	 : [REQUIRED] {config["output"]} output file name')
	print(f'  -f|--from	  : [REQUIRED] input {config["input"]} data type')
	print(f'  -t|--type	  : [REQUIRED] output {config["output"]} data type')
	print(f'  -p|--property  : [OPTIONAL] property option')
	print(f'  -C|--class	 : [OPTIONAL] default class definition when generating GLM objects')
	print(f'  -M|--module	: [OPTIONAL] default module definition when generating GLM objects')
	print(f'  -O|--option=KEY:VALUE : [OPTIONAL] set converter option KEY=VALUE')

def error(msg):
	print(f'ERROR	[{config["input"]}2{config["output"]}]: {msg}')
	sys.exit(1)

def vertices(data):
	pts = []
	for key,value in data.items():
		if key.startswith('X,Y,Z Vertex'):
			pts.append(value)
	return Polygon(pts)

# TODO: remove default files (only for dev)
input_files = [] #["autotest/test_idf2glm_input.idf"]
output_file = None # "autotest/test_idf2glm_output.glm"
options = {}

opts, args = getopt.getopt(sys.argv[1:],"hi:o:",["help","config","ifile=","ofile="])

# if not opts : 
#	 help()
#	 sys.exit(1)

for opt, arg in opts:
	if opt in ("-h","--help"):
		help()
		sys.exit(0)
	elif opt in ("-i","--input"):
		input_files.append(arg.strip())
	elif opt in ("-o","--output"):
		output_file = arg.strip()
	else:
		error(f"{opt}={arg} is not a valid option");

if not input_files:
	error("missing input file name")
elif output_file == None:
	error("missing output file name")

with open(output_file,"wt") as glm:
	glm.write(f"""// generated by {' '.join(sys.argv)} on {datetime.datetime.now()}
// output to {output_file}
class building 
{{
	double dt[s]; // timestep to use when modeling building response to inputs
	double TA[degC]; // (OUTPUT) indoor air temperature
	double TM[degC]; // (OUTPUT) building mass temperature
	double M[pu]; // (OUTPUT) system mode per unit system capacity
	double ES[J]; // (OUTPUT) stored energy
	double UA[W/K]; // (REQUIRED) conductance from interior air to outdoor air
	double CA[J/K]; // (REQUIRED) heat capacity of indoor air volume
	double UI[W/K]; // (REQUIRED) conductance from building mass to indoor air
	double CM[J/K]; // (REQUIRED) heat capacity of building mass
	double UM[W/K]; // (REQUIRED) conductance of building mass to outdoor air
	double TH[degC]; // (REQUIRED) heating design temperature
	double TC[degC]; // (REQUIRED) cooling design temperature
	double DF[pu]; // system over-design factor
	double QH[W]; // (REQUIRED,OUTPUT) HVAC system capacity
	double QE[W/m^2]; // (REQUIRED) nomimal enduse load capacity
	double QG[W/m^2]; // (REQUIRED) natural gas heat per unit nominal enduse capacity
	double QO[W/unit]; // (REQUIRED) heat gain per occupant
	double QV[W/unit]; // (REQUIRED) ventilation gain per occupant
	double SA[m^2]; // (REQUIRED) building mass area exposed to solar radiation
	double PV[m^2]; // area of photovoltaic rooftop panels
	double BS[J]; // battery storage capacity
	double PX[W]; // maximum export power
	double PG[W]; // maximum inverter power
	double K[pu]; // HVAC mode proportional control gain w.r.t indoor temperature
	enumeration {{UL1741=3, CARULE21=2, IEEE1547=1, UNITY=0}} IC; // inverter power factor control
	double TO[degC]; // outdoor air temperature
	double EU[unit]; // enduse load fraction
	double NG[unit]; // natural gas demand
	double NH[unit]; // building occupants
	double QS[W/m^2]; // insolation
	double TS[degC]; // (REQUIRED) thermostat setpoint
	double PZM[pu]; // (OUTPUT) constant impedance HVAC real power per unit system capacity
	double PPM[pu]; // (OUTPUT) constant power HVAC real power per unit system capacity
	double QPM[pu]; // (OUTPUT) constant power HVAC reactive power per unit system capacity
	double PZE[pu]; // (OUTPUT) constant impedance end-use real power fraction
	double PIE[pu]; // (OUTPUT) constant current end-use real power fraction
	double PPE[pu]; // (OUTPUT) constant power end-use real power fraction
	double QZE[pu]; // (OUTPUT) constant impedance end-use reactive fraction
	double QIE[pu]; // (OUTPUT) constant current end-use reactive fraction
	double QPE[pu]; // (OUTPUT) constant power end-use reactive fraction
	double PPH[pu]; // (OUTPUT) constant power ventilation real power per unit occupancy
	double QPH[pu]; // (OUTPUT) constant power ventilation reactive power per unit occupancy
	double measured_real_power[W]; // (OUTPUT) metered real power demand
	double measured_reactive_power[VAr]; // (OUTPUT) metered reactive power demand
	double measured_real_energy[Wh]; // (OUTPUT) cumulative metered real energy consumption
	double measured_real_energy_delta[Wh]; // (OUTPUT) metered real energy interval consumption
	double measured_reactive_energy[Wh]; // (OUTPUT) cumulative metered reactive energy consumption
	double measured_reactive_energy_delta[Wh]; // (OUTPUT) metered reactive energy interval consumption
	double measured_energy_delta_timestep[s]; // (OUTPUT) energy metering interval
	double measured_demand[W]; // (OUTPUT) maximum metered real power interval demand
	double measured_demand_timestep[s]; // (OUTPUT) maximum power metering interval
	double measured_resource_power[W]; // (OUTPUT) measured net distributed generation production from solar and batteries
	char256 temperature_source; // temperature weather object source property
	char256 solar_source; // solar weather object source property
	char256 cooling_design; // cooling design temperature source property
	char256 heating_design; // heating design temperature source property
	char32 building_type; // building type used to be lookup defaults and enduse loadshapes
	double floor_area[m^2]; // (REQUIRED) building floor area
	double electric_gain_fraction[pu]; // (REQUIRED) fraction of electric end-use heat gain to the building
	double gas_gain_fraction[pu]; // (REQUIRED) fraction of gas end-use heat gain to the building
	double electrification_fraction[pu]; // (REQUIRED) fraction of gas enduses that are converted to electricity
	double electrification_efficiency[pu]; // (REQUIRED) performance of electric end-use relative to gas enduse
	int32 occupancy; // building occupancy
	bool electric_heat; // flag to specified whether heating is electric
}}
""")
	for file in input_files:
		idf = IDF(file)

		# clean the name
		name = re.sub('[^-0-9A-Za-z_]','',list(idf['Building'].keys())[0].replace(' ','_'));
		name = re.sub('_+','_',name).strip('_')
		if name[0] == '-':
			name = name[1:63]

		location = list(idf['Site:Location'].keys())[0]
		latitude = idf['Site:Location'][location]['Latitude {deg}']
		longitude = idf['Site:Location'][location]['Longitude {deg}']
		occupancy = sum([data['People per Zone Floor Area {person/m2}'] for data in idf['People'].values()])
		lighting = sum([data['Watts per Zone Floor Area {W/m2}'] for data in idf['Lights'].values()])
		equipment = sum([data['Watts per Zone Floor Area {W/m2}'] for data in idf['ElectricEquipment'].values()])
		
		# basic building properties
		floor_area = sum([vertices(data).area() for data in idf['BuildingSurface:Detailed'].values() if data['Surface Type'] == 'Floor'])
		wall_perimeter = sum([vertices(data).perimeter() for data in idf['BuildingSurface:Detailed'].values() if data['Surface Type'] == 'Floor'])
		wall_height = max([vertices(data).height() for data in idf['BuildingSurface:Detailed'].values() if data['Surface Type'] == 'Wall'])
		wall_area = sum([vertices(data).area() for data in idf['BuildingSurface:Detailed'].values() if data['Surface Type'] == 'Wall'])
		window_area = sum([vertices(data).area() for data in idf['FenestrationSurface:Detailed'].values() if data['Surface Type'] == 'Window'])
		roof_area = sum([vertices(data).area() for data in idf['BuildingSurface:Detailed'].values() if data['Surface Type'] == 'Roof'])

		# surface properties
		thermal_conductance = 0.0
		thermal_mass = 0.0
		solar_absorptance = 0.0
		solar_transmittance = 0.0;
		for surface in idf['BuildingSurface:Detailed'].values():
			surface_name = surface['Construction Name']
			area = vertices(surface).area()
			if surface_name in idf['Construction:FfactorGroundFloor']:
				construction = idf['Construction:FfactorGroundFloor'][surface_name]
				# print(construction)
				f_factor = construction['F-Factor {W/m-K}']
				perimeter = construction['PerimeterExposed {m}']
				thermal_conductance += f_factor * perimeter
			elif surface_name in idf['Construction']:
				construction = idf['Construction'][surface_name]
				for name in construction.values():
					if name in idf['Material']:
						layer = idf['Material'][name]
						conductivity = layer['Conductivity {W/m-K}']
						thickness= layer['Thickness {m}']
						specific_heat = layer['Specific Heat {J/kg-K}']
						density = layer['Density {kg/m3}']
						thermal_conductance += conductivity*thickness*area
						thermal_mass += specific_heat*density*thickness*area
					elif name in idf['Material:NoMass']:
						layer = idf['Material:NoMass'][name]
						resistance = layer['Thermal Resistance {m2-K/W}']
						thermal_conductance += area/resistance
					else:
						raise Exception(f"'{name}' not found")
					# TODO: get absorptance values
			else:
				raise Exception(f"'{surface_name}' not found")

		for surface in idf['FenestrationSurface:Detailed'].values():
			#print(surface)
			# TODO: get window values
			pass

		glm.write(f"""
// input from {file}
object building {{
	name "{name[:63]}";
	latitude {latitude};
	longitude {longitude};
	temperature_source "{geohash(latitude,longitude,6)}.temperature";
	solar_source "{geohash(latitude,longitude,6)}.solar_global";
	UA
	// occupancy {occupancy*floor_area:.0f} unit;
	// lighting {lighting*floor_area:.0f} W;
	// equipment {equipment*floor_area:.0f} W;
	// floor_area {floor_area:.1f} m^2;
	// perimeter {wall_perimeter:.1f} m;
	// window_area {window_area:.1f} m^2;
	// wall_area {wall_area:.1f} m^2;
	// roof_area {roof_area:.1f} m^2;
	// thermal_conductance {thermal_conductance:.1f} W/K;
	// thermal_mass {thermal_mass/1e6:.1f} MJ/K;
	// solar_absorptance {solar_absorptance:.3f} pu;
	// solar_transmittance {solar_transmittance:.3f} pu;
}}
//#set savefile=${{modelname/.glm/.json}}
""")

		# json.dump(idf,sys.stdout,indent=4)

