# Syntax: read_dlp FILENAME.DLP [OPTIONS ...] 
"""Read Dynamic Load Profile

Syntax: python3 -m read_dlp FILENAME.DLP [OPTIONS ...] 

Options
-------

	[-c|--csv=CSVNAME] 
	[-d|--debug]
	[-g|--glm=GLMNAME] 
	[-h|--help|help]
	[-n|--name=OBJNAME] 
	[-p|--property=PROPERTY]
	[-q|--quiet]
	[-w|--warning]

Description
-----------

The `read_dlp` tool converts a DLP file and to a corresponding GridLAB-D player
with data. The output of the DLP reader is a GLM and a CSV file. If no CSVNAME
is given the default CSV file name is same of input FILENAME with the ".csv"
extension.  If no GLMNAME is the default GLM file name is similarly named with
the ".glm" extension.

The output of either the CSV or GLM may be blocked using the flag with no name
given.  If the GLM file is omitted, then the CSV file is output with headers.
Otherwise it is output without header to be compatible with the GLM "player"
object.  The "player" object will used the PROPERTY name to identify the
object to which the DLP data is applied.  The default PROPERTY name is the
basename of the input FILENAME.

Caveats
-------

DLP files must be obtained directly from the utilities. The read does not
support direct retrieval of DLP files from utilities unless the full URL is
provided as the FILENAME.
"""

import os, sys
import pandas
import datetime

EXENAME = os.path.basename(os.path.splitext(sys.argv[0])[0])
CSVNAME = ''
GLMNAME = ''
OBJNAME = None
PROPERTY = "power"
QUIET = False
DEBUG = False
WARNING = False

class GldReadDlpException(Exception):
	pass

E_OK = 0
E_FAILED = 1
E_NOTFOUND = 2
E_INVALID = 3
E_MISSING = 4
E_SYNTAX = 9

def error(msg,code=None):
	if DEBUG:
		raise GldReadDlpException(msg)
	elif not QUIET:
		print(f"ERROR [{EXENAME}]: {msg}",file=sys.stderr)
	elif type(code) is int:
		exit(code)
	elif code != None:
		raise Exception("error code '{code}' is invalid")

def warning(msg):
	if not WARNING:
		print(f"WARNING [{EXENAME}]: {msg}",file=sys.stderr)

def read_dlp(dlpfile):
	"""Read DLP file"""
	data = pandas.read_csv(dlpfile,
		usecols=range(1,26),
		index_col=[0],
		parse_dates=[1])

	columns = []
	for col in data.columns:
		h = int(col.split(":")[0])-1
		if col.endswith("PM"):
			h += 12
		columns.append(h)
	data.columns = columns

	load = data.unstack().reset_index()
	load.columns = ["hour","date","load"]
	load["date"] = pandas.DatetimeIndex(load["date"]) + pandas.TimedeltaIndex(load["hour"],unit='h')
	load.drop("hour",axis=1,inplace=True)
	load.set_index("date",inplace=True)
	load.sort_index(inplace=True)

	return load

def write_glm(glmname,csvname,objname,propertyname):
	"""Write GLM file for DLP data"""
	with open(glmname,"w") as glm:
		glm.write(f"""// generated by {' '.join(sys.argv)} on {datetime.datetime.now()}
module tape;
object player
{{
	parent "{objname}";
	file "{csvname}";
	property "{propertyname}";
}}
""")

if __name__ == "__main__":
	
	if len(sys.argv) == 1:
		print(__doc__.split("\n")[2],file=sys.stderr)
		exit(E_SYNTAX)

	if sys.argv[1] in ["-h","--help","help"]:
		print(__doc__)
		exit(E_OK)

	FILENAME = sys.argv[1]
	if not os.path.exists(sys.argv[1]):
		error(f"file '{FILENAME}' not found",E_NOTFOUND)

	for arg in sys.argv[2:]:
		args = arg.split("=")
		if len(args) == 1:
			tag = arg
			value = None
		else:
			tag = args[0]
			value = args[1]
		if tag in ["-c","--csv"]:
			CSVNAME = value
		elif tag in ["-g","--glm"]:
			GLMNAME = value
		elif tag in ["-n","--name"]:
			OBJNAME = value
		elif tag in ["-p","--property"]:
			PROPERTY = value
		elif tag in ["-d","--debug"]:
			DEBUG = True
		elif tag in ["-q","--quiet"]:
			QUIET = True
		elif tag in ["-w","--warning"]:
			WARNING = True
		else:
			error(f"option '{arg}' is not valid",E_INVALID)

	if CSVNAME == '':
		CSVNAME = os.path.splitext(FILENAME)[0] + ".csv"

	if GLMNAME == '':
		GLMNAME = os.path.splitext(FILENAME)[0] + ".glm"

	if OBJNAME == '':
		OBJNAME = os.path.basename(os.path.splitext(FILENAME)[0])

	dlp = read_dlp(FILENAME)
	if GLMNAME:
		write_glm(GLMNAME,CSVNAME,OBJNAME,PROPERTY)
		if CSVNAME:
			dlp.to_csv(CSVNAME,index=True,header=False)
		else:
			warning(f"GLM file '{GLMNAME}' refers to CSV file '{CSVNAME}' that was not saved")			
	else:
		if CSVNAME:
			dlp.to_csv(CSVNAME,index=True,header=True)
