"""Create loads

Syntax:

    $ gridlabd create_loads [OPTIONS ...]

    Options:
        
        -i|--input=NETWORK_MODEL

            Specify the input network model (default is /dev/stdin as JSON)
        
        -o|--output=LOAD_MODEL

            Specify the output network model (default is /dev/stdout as GLM)

        KEY=VALUE

            Set an option. Valid options and defaults are:
                HOUSE_LOAD = 10e3
                MIN_POWER_FACTOR = -0.85
                MAX_POWER_FACTOR = 0.85
                FIX_POWER_FACTOR = True
                TRANSFORMER_INSTALL_TYPE = "PADMOUNT"
                HOUSES_PER_TRANSFORMER = 4
                TRANSFORMER_OVERSIZE_FACTOR = 2.0
                SECONDARY_VOLTAGE = "120 V"
                TRANSFORMER_CONNECTION = "SINGLE_PHASE_CENTER_TAPPED"
                TRANSFORMER_RESISTANCE = "0.01 Ohm"
                TRANSFORMER_REACTANCE = "0.06 Ohm"


The `create_loads` tool generates a physical load model for a network model.

"""

import os, sys
import json, math, random
import datetime

EXENAME = os.path.basename(os.path.splitext(sys.argv[0])[0])

DEBUG = False
QUIET = False
WARNING = True
VERBOSE = False

E_OK = 0
E_FAILED = 1
E_MISSING = 2
E_INVALID = 3
E_SYNTAX = 9

class CreateLoadsError(Exception):
    pass

def error(msg,code=None):
    if type(code) is int:
        msg += f"(code {code})"
    elif code != None:
        raise CreateLoadsError(f"error code '{code}' is invalid")
    if not QUIET:
        print(f"ERROR [{EXENAME}]: {msg}",file=sys.stderr)
    if DEBUG:
        raise CreateLoadsError(msg)
    exit(code)

def warning(msg):
    if WARNING:
        print(f"WARNING [{EXENAME}]: {msg}",file=sys.stderr)

def debug(msg):
    if DEBUG:
        print(f"DEBUG [{EXENAME}]: {msg}",file=sys.stderr)

def verbose(msg):
    if VERBOSE:
        print(f"VERBOSE [{EXENAME}]: {msg}",file=sys.stderr)

NETWORK_FILE = None
OUTPUT_FILE = None
OPTIONS = dict(
    HOUSE_LOAD = 10e3, # Load of a single house in Watts
    MIN_POWER_FACTOR = -0.85,
    MAX_POWER_FACTOR = 0.85,
    FIX_POWER_FACTOR = True,
    TRANSFORMER_INSTALL_TYPE = "PADMOUNT",
    HOUSES_PER_TRANSFORMER = 4,
    TRANSFORMER_OVERSIZE_FACTOR = 2.0,
    SECONDARY_VOLTAGE = "120 V",
    TRANSFORMER_RESISTANCE = "0.01 Ohm",
    TRANSFORMER_REACTANCE = "0.06 Ohm",
)

transformers = {}

def phase_count(phases):
    return int("A" in phases) + int("B" in phases) + int("C" in phases)

def is_triplex(phases):
    return "S" in phases

def connect_type(primary,secondary):
    if is_triplex(secondary):
        return "SINGLE_PHASE_CENTER_TAPPED";
    elif phase_count(secondary) == 1:
        return "SINGLE_PHASE"
    elif "D" in primary and not "N" in primary:
        if not "D" in secondary and ("N" in secondary or "G" in secondary):
            return "DELTA_GWYE"
        elif "D" in secondary:
            return "DELTA_DELTA"
    elif not "D" in primary and not "D" in secondary:
        return "WYE_WYE" 
    raise CreateLoadsError(f"transformer connection from {primary} to {secondary} not supported")

def connect_secondary(phases):
    if is_triplex(phases):
        if "A" in phases: return "AS"
        if "B" in phases: return "BS"
        if "C" in phases: return "CS"
        raise CreateLoadsError(f"secondary connection for {phases} is not possible")
    return phases

def glm_header(inputfile,outputfile):
    return f"""// Generated by {EXENAME} at {datetime.datetime.now()}
//
// Options:
//    inputfile = {inputfile}
//    outputfile = {outputfile}
//
// Settings:
//    HOUSE_LOAD = {HOUSE_LOAD}
//    MIN_POWER_FACTOR = {MIN_POWER_FACTOR}
//    MAX_POWER_FACTOR = {MAX_POWER_FACTOR}
//    FIX_POWER_FACTOR = {FIX_POWER_FACTOR}
//    TRANSFORMER_INSTALL_TYPE = {TRANSFORMER_INSTALL_TYPE}
//    HOUSES_PER_TRANSFORMER = {HOUSES_PER_TRANSFORMER}
//    TRANSFORMER_OVERSIZE_FACTOR = {TRANSFORMER_OVERSIZE_FACTOR}
//    SECONDARY_VOLTAGE = {SECONDARY_VOLTAGE}
//    TRANSFORMER_RESISTANCE = {TRANSFORMER_RESISTANCE}
//    TRANSFORMER_REACTANCE = {TRANSFORMER_REACTANCE}
module residential;
module powerflow;
"""

def glm_transformer_configuration(configuration,nominal_voltage,primary_phases):
    result = f"""object transformer_configuration {{
    name "{configuration}";
    primary_voltage {nominal_voltage} V;
    secondary_voltage {SECONDARY_VOLTAGE};
    connect_type {connect_type(primary_phases,connect_secondary(primary_phases))};
    resistance {TRANSFORMER_RESISTANCE};
    reactance {TRANSFORMER_REACTANCE};
    install_type "{TRANSFORMER_INSTALL_TYPE}";
    power_rating {HOUSE_LOAD*HOUSES_PER_TRANSFORMER*TRANSFORMER_OVERSIZE_FACTOR};
}}"""
    debug(f"glm_transformer_configuration(configuration={configuration},nominal_voltage={nominal_voltage}) -> {result}")
    return result

def glm_transformer(obj,n,configuration,phases):
    return f""" object transformer {{
    name "{obj}_xfrm_{phases}_{n}";
    from "{obj}";
    to "{obj}_meter_{n}";
    phases {phases};
    configuration "{configuration}";
}}
"""

def glm_house(obj,n,phases,parent=None):
    if parent:
        parent = f'\n    parent "{parent}";'
    else:
        parent = ''
    return f"""object {'triplex_meter' if is_triplex(phases) else 'meter'} {{
    name `{obj}_meter_{n}`;{parent}
    phases {phases};
    nominal_voltage {SECONDARY_VOLTAGE};
    object house:..{n} {{
        name `{obj}_house_{{id}}`;
    }};
}}
"""

def main(inputfile,outputfile,**kwargs):
    """Generate GLM with load objects for a network
    Parameters:
    - inputfile (str):
    - outputfile (str):
    Returns:
    - Output file name (str) if output file set, or GLM data is outputfile is None
    """

    for key,value in OPTIONS.items():
        globals()[key] = value
    for key,value in kwargs.items():
        if key not in OPTIONS.keys():
            raise CreateLoadsError(f"option '{key}={value}' is invalid",E_INVALID)
        globals()[key] = value
    debug(globals())

    # convert GLM to JSON 
    if os.path.splitext(inputfile)[1] == ".glm":
        os.system(f"gridlabd -C '{inputfile}' -o '{os.path.splitext(inputfile)[0]}.json'")
        inputfile = os.path.splitext(inputfile)[0] + ".json"

    # load JSON
    with open(inputfile,"r") as fh:
        glm = json.load(fh)

    # prepare result data
    result = [glm_header(inputfile,outputfile)]
    for obj, data in glm['objects'].items():
        n = 0
        if data['class'] == 'load':
            for key, value in data.items():
                if key.startswith('constant_') and not key.endswith('_real') and not key.endswith('_reac'):
                    load = complex(value.split()[0])
                    if load != 0j:

                        # zero the original load object
                        n_houses = int(load.real/10000)+1
                        power_factor = (+1 if load.imag<0 else +1) * round(load.real/abs(load),2)
                        result.append(f'modify {obj}.{key} "0+0i"; // {data["class"]} is {load} -> {n_houses} houses with power factor {power_factor}')
                        
                        # fix power factor
                        if MIN_POWER_FACTOR < power_factor < MAX_POWER_FACTOR:
                            if FIX_POWER_FACTOR:
                                power_factor = -min(MIN_POWER_FACTOR,max(MAX_POWER_FACTOR,power_factor))
                                load = complex(load.real,round(load.real*math.tan(math.acos(power_factor)),2))
                                result[-1] += f", fixed to {power_factor}, reactive power={load.imag}"
                            else:
                                warning(f"{obj}.{key} load {load} has an unusually low power factor={power_factor}")

                        # generator transformer object
                        nominal_voltage = int(float(data['nominal_voltage'].split()[0]))
                        primary_phases = data['phases']
                        secondary_phases = connect_secondary(primary_phases)
                        if nominal_voltage > int(float(SECONDARY_VOLTAGE.split()[0])):
                            configuration_name = f"xfrmcfg_{data['phases']}_{nominal_voltage}"
                            if configuration_name in transformers.keys():
                                configuration = transformers[configuration_name]
                            else:

                                # create the transformer configuration first
                                transformers[configuration_name] = glm_transformer_configuration(configuration_name,nominal_voltage,primary_phases)
                                result.append(transformers[configuration_name])

                            result.append(glm_transformer(obj,n,configuration_name,primary_phases))
                            parent = None

                        # generate house object
                        result.append(glm_house(obj,n,secondary_phases,parent))
                        # print(obj,key,load)
                n += 1
    if outputfile:
        with open(outputfile,"w") as fh:
            print('\n'.join(result),file=fh)
    else:  
        return '\n'.join(result)

if __name__ == "__main__":

    if len(sys.argv) == 1:
        print("Syntax: gridlabd create_loads NETWORK_FILE.[glm,json] -o LOAD_FILE.[glm,json] [OPTIONS ...]",file=sys.stderr)
        exit(E_SYNTAX)

    inputfile = "/dev/stdin"
    outputfile = "/dev/stdout"
    options = {}
    for arg in sys.argv[1:]:
        spec = arg.split("=")
        tag = spec[0]
        if len(spec) == 1:
            value = True
        elif len(spec) == 2:
            if "," in spec[1]:
                value = spec[1].split(",")
            else:
                value = spec[1]
        else:
            value = "=".join(spec[1:])

        if tag in ["-h","--help","help"]:
            print(__doc__)
            inputfile = None
            break
        elif tag in ["-i","--inputfile"]:
            inputfile = value
        elif tag in ["-o","--outputfile"]:
            outputfile = value
        elif tag in ["-d","--debug"]:
            DEBUG = True
        elif tag in ["-v","--verbose"]:
            VERBOSE = True
        elif tag in ["-q","--quiet"]:
            QUIET = True
        elif tag in ["-w","--warn"]:
            WARNING = False
        elif tag in OPTIONS.keys():
            options[tag] = value
        else:
            error(f"option '{arg}' is invalid")

    if inputfile:
        result = main(inputfile,outputfile,**OPTIONS)
        if result:
            print(result,file=sys.stdout)

